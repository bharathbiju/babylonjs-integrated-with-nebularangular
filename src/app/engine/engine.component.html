<canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true }); };
        
        BABYLON.DefaultLoadingScreen.prototype.displayLoadingUI = function () {
            if (this._loadingDiv) {
                // Do not add a loading screen if there is already one
                return;
            }
            this._loadingDiv = document.createElement("div");
            this._loadingDiv.id = "babylonjsLoadingDiv";
            this._loadingDiv.style.opacity = "0";
            this._loadingDiv.style.transition = "opacity 1.5s ease";
            this._loadingDiv.style.pointerEvents = "none";
            // Loading text
            this._loadingTextDiv = document.createElement("div");
            this._loadingTextDiv.style.position = "absolute";
            this._loadingTextDiv.style.left = "0";
            this._loadingTextDiv.style.top = "50%";
            this._loadingTextDiv.style.marginTop = "80px";
            this._loadingTextDiv.style.width = "100%";
            this._loadingTextDiv.style.height = "20px";
            this._loadingTextDiv.style.fontFamily = "Arial";
            this._loadingTextDiv.style.fontSize = "14px";
            this._loadingTextDiv.style.color = "white";
            this._loadingTextDiv.style.textAlign = "center";
            this._loadingTextDiv.innerHTML = "Loading";
            this._loadingDiv.appendChild(this._loadingTextDiv);
            //set the predefined text
            this._loadingTextDiv.innerHTML = this._loadingText;
            // Generating keyframes
            var style = document.createElement('style');
            style.type = 'text/css';
            var keyFrames = "@-webkit-keyframes spin1 { 0% { -webkit-transform: rotate(0deg);}\n                    100% { -webkit-transform: rotate(360deg);}\n                }                @keyframes spin1 {                    0% { transform: rotate(0deg);}\n                    100% { transform: rotate(360deg);}\n                }";
            style.innerHTML = keyFrames;
            document.getElementsByTagName('head')[0].appendChild(style);
            // Loading img
            var imgBack = new Image();
            imgBack.src = "http://noticeperiod.xyz/stall/textures/proto.png";
            imgBack.style.position = "absolute";
            imgBack.style.left = "25%";
            imgBack.style.top = "25%";
            imgBack.style.marginLeft = "-60px";
            imgBack.style.marginTop = "-60px";
            imgBack.style.animation = "spin1 2s infinite ease-in-out";
            imgBack.style.webkitAnimation = "spin1 2s infinite ease-in-out";
            imgBack.style.transformOrigin = "50% 50%";
            imgBack.style.webkitTransformOrigin = "50% 50%";
            this._loadingDiv.appendChild(imgBack);
            this._resizeLoadingUI();
            window.addEventListener("resize", this._resizeLoadingUI);
            this._loadingDiv.style.backgroundColor = this._loadingDivBackgroundColor;
            document.body.appendChild(this._loadingDiv);
            this._loadingDiv.style.opacity = "1";
        };
             
        
        
        
        
        
        
        var delayCreateScene = function () {
        
            // Model by Mixamo
        
            engine.enableOfflineSupport = false;
            
            // This is really important to tell Babylon.js to use decomposeLerp and matrix interpolation
            BABYLON.Animation.AllowMatricesInterpolation = true;
        
            var scene = new BABYLON.Scene(engine);
        
            var camera = new BABYLON.ArcRotateCamera("camera1", Math.PI / 1, Math.PI / 2, 3, new BABYLON.Vector3(0, 0.2, 0), scene);
            camera.lowerBetaLimit = 0.1;
            camera.upperBetaLimit = (Math.PI / 2) * 0.9;
            camera.lowerRadiusLimit = 0;
            camera.upperRadiusLimit = 150;
            camera.attachControl(canvas, true);
        
            camera.lowerRadiusLimit = 2;
            camera.upperRadiusLimit = 10;
            camera.wheelDeltaPercentage = 0.01;
        
        	var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
        	light.intensity = 0.6;
        	light.specular = BABYLON.Color3.Black();
        
            var light2 = new BABYLON.DirectionalLight("dir01", new BABYLON.Vector3(0, -2, -5.0), scene);
            light2.position = new BABYLON.Vector3(0, 5, 5);
        
            // Shadows
            var shadowGenerator = new BABYLON.ShadowGenerator(1024, light2);
            shadowGenerator.useBlurExponentialShadowMap = true;
            shadowGenerator.blurKernel = 32;
        	
            engine.displayLoadingUI();

        	/* BABYLON.SceneLoader.ImportMesh("", "./source/", "stall.babylon", scene, function (newMeshes, particleSystems, stall) {
                var stallnew = stall[0];

                shadowGenerator.addShadowCaster(scene.meshes[0], true);
                for (var index = 0; index < newMeshes.length; index++) {
                    newMeshes[index].receiveShadows = false;;
                } */
        
                /* var helper = scene.createDefaultEnvironment({
                    enableGroundShadow: true
                }); */
               /*  helper.setMainColor(BABYLON.Color3.Gray());
                helper.ground.position.y += 0.01;  */      
                // ROBOT        		       

        
                /* engine.hideLoadingUI();
            }); */
/* 
            BABYLON.SceneLoader.ImportMesh("", "./source/", "stall.babylon", scene, function (newMeshes, particleSystems, stall) {
                var stallnew = stall[0];
                
                shadowGenerator.addShadowCaster(scene.meshes[0], true);
                for (var index = 0; index < newMeshes.length; index++) {
                    newMeshes[index].receiveShadows = false;;
                }
        
                var helper = scene.createDefaultEnvironment({
                    enableGroundShadow: true
                });
                helper.setMainColor(BABYLON.Color3.Gray());
                helper.ground.position.y += 0.01;       
                // ROBOT        		       

        
                engine.hideLoadingUI();
            }); */

            var assetsManager = new BABYLON.AssetsManager(scene);
	        var meshTask = assetsManager.addMeshTask("skull task", "", "scenes/", "stall_inner.babylon");
	
	        meshTask.onSuccess = function (task) {
	                task.loadedMeshes[0].position = BABYLON.Vector3.Zero();
	        }

            // Move the light with the camera
    /* scene.registerBeforeRender(function () {
        light.position = camera.position;
    });
	
	assetsManager.onFinish = function (tasks) {
		engine.runRenderLoop(function () {
			scene.render();
		});
	}; */
	
	assetsManager.load();

            
        
            return scene;
        };
        
    var engine;
    try {
    engine = createDefaultEngine();
    } catch(e) {
    console.log("the available createEngine function failed. Creating the default engine instead");
    engine = createDefaultEngine();
    }
        if (!engine) throw 'engine should not be null.';
        scene = delayCreateScene();;
        sceneToRender = scene

        engine.runRenderLoop(function () {
            if (sceneToRender) {
                sceneToRender.render();
            }
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>